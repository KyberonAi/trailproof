# Spec: Core API

branch: feature/core-api

## Status
Approved

## Problem
Trailproof has no implementation yet — only project scaffolding. Developers need a working tamper-evident audit trail library that records events, chains them cryptographically via SHA-256, and verifies nothing was modified after the fact. Both Python and TypeScript SDKs must ship with identical behavior and shared test vectors.

## Goals
- Ship the complete Trailproof v1.0 public API: emit, query, verify, get_trace, flush
- Implement the 10-field TrailEvent envelope with SHA-256 hash chaining
- Provide two storage backends: in-memory (default) and JSONL file (persistent)
- Support optional HMAC-SHA256 signing for event provenance
- Achieve identical hashes across Python and TypeScript for the same event data
- Pass shared cross-SDK test vectors defined in fixtures/test-vectors.json

## Non-Goals
- External trust anchoring (Rekor, S3 object-lock)
- KMS/HSM key management or key rotation
- Compliance-ready event schemas or evidence bundles
- OTel exporters or framework adapters (LangChain, CrewAI)
- CLI tooling
- Async batching, retention/TTL, or pub-sub
- Payload schema validation — Trailproof stores payload opaquely

## Background
Trailproof is a shared substrate for Attesta (approval workflows) and Memproof (memory governance). The hash chain design is adopted from Attesta's existing TypeScript implementation. Both SDKs must be zero-dependency at runtime — Python uses stdlib only, TypeScript uses Node.js built-ins only.

SPEC.md is the source of truth for all design decisions in this spec.

## Solution Overview
Build the library in layers: types and errors first (foundation), then the hash chain engine with canonical JSON, then storage backends, then the Trailproof facade class that ties everything together, and finally the optional HMAC signer. Python is built first for each layer, TypeScript mirrors after.

## Design Details

### Data Model

**TrailEvent** — 10-field event envelope:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| event_id | string | yes | UUID v4, generated by Trailproof |
| event_type | string | yes | Namespaced type (e.g., memproof.memory.write) |
| timestamp | string | yes | ISO-8601 UTC, generated by Trailproof |
| actor_id | string | yes | Who performed the action |
| tenant_id | string | yes | Tenant/org isolation key |
| trace_id | string | no | Cross-system correlation |
| session_id | string | no | Session grouping |
| payload | object | yes | Domain-specific data (opaque to Trailproof) |
| prev_hash | string | yes | Hash of previous event (genesis: "0" x 64) |
| hash | string | yes | SHA-256(prev_hash + canonical_json(event)) |
| signature | string | no | hmac-sha256:<hex> if signer configured |

**QueryResult** — { events, next_cursor }

**VerifyResult** — { intact, total, broken }

**QueryFilters** — { event_type?, actor_id?, tenant_id?, trace_id?, session_id?, from_time?, to_time?, limit, cursor? }

**Error hierarchy:**
- TrailproofError (base)
  - ValidationError (missing/invalid fields)
  - StoreError (storage failures)
  - ChainError (broken hash chain)
  - SignatureError (HMAC verification failed)

### API Surface

```python
# Python
from trailproof import Trailproof, TrailEvent, QueryResult, VerifyResult

# Construction
tp = Trailproof()                                    # in-memory, no signing
tp = Trailproof(store="jsonl", path="events.jsonl")  # JSONL file
tp = Trailproof(signing_key="secret")                # with HMAC
tp = Trailproof(default_tenant_id="acme-corp")       # default tenant

# Core methods
event: TrailEvent = tp.emit(
    event_type="memproof.memory.write",
    actor_id="agent-47",
    tenant_id="acme-corp",
    payload={"key": "value"},
    trace_id="trace-abc",       # optional
    session_id="session-xyz",   # optional
)

result: QueryResult = tp.query(
    event_type="...",           # all filters optional
    actor_id="...",
    tenant_id="...",
    trace_id="...",
    session_id="...",
    from_time="2025-01-01T00:00:00Z",
    to_time="2025-12-31T23:59:59Z",
    limit=100,
    cursor=None,
)

verification: VerifyResult = tp.verify()
events: list[TrailEvent] = tp.get_trace("trace-abc")
tp.flush()
```

```typescript
// TypeScript
import { Trailproof, TrailEvent, QueryResult, VerifyResult } from "@kyberon/trailproof";

// Construction
const tp = new Trailproof();
const tp = new Trailproof({ store: "jsonl", path: "events.jsonl" });
const tp = new Trailproof({ signingKey: "secret" });
const tp = new Trailproof({ defaultTenantId: "acme-corp" });

// Core methods
const event: TrailEvent = tp.emit({
    eventType: "memproof.memory.write",
    actorId: "agent-47",
    tenantId: "acme-corp",
    payload: { key: "value" },
    traceId: "trace-abc",       // optional
    sessionId: "session-xyz",   // optional
});

const result: QueryResult = tp.query({
    eventType: "...",           // all filters optional
    actorId: "...",
    limit: 100,
});

const verification: VerifyResult = tp.verify();
const events: TrailEvent[] = tp.getTrace("trace-abc");
tp.flush();
```

### Key Logic

**Canonical JSON** — deterministic serialization for reproducible hashes:
- Keys sorted alphabetically (recursive for nested objects)
- Compact format: no whitespace (separators: "," and ":")
- Exclude "hash" and "signature" fields
- Exclude null/None fields
- UTF-8 encoding

**Hash chain** — each event's hash depends on the previous:
- Genesis hash: "0" x 64 (64 zero characters)
- hash = SHA-256(prev_hash + canonical_json(event))
- Verification walks the chain; if event N is tampered, events N through end all show as broken

**HMAC signing** — optional provenance layer:
- signature = "hmac-sha256:" + HMAC-SHA256(key, canonical_json(event))
- Verification uses timing-safe comparison
- Hash chain works independently of signing

**Store interface** — append-only contract:
- append(event) — add one event
- read_all() — return all events in order
- query(filters) — filtered read with pagination
- last_hash() — return the most recent hash (for chain resumption)
- count() — total events stored

**JSONL store specifics:**
- One JSON object per line, append-only
- File created with 0o600 permissions
- On init: reads existing file, recovers last_hash and count
- Corrupt lines: skip, log warning, include index in broken on verify

**Cursor pagination:**
- next_cursor returned when more results exist beyond limit
- Pass cursor back to resume from that event_id

## Edge Cases
- First event in an empty chain uses genesis hash as prev_hash
- emit() with missing required field (event_type, actor_id, tenant_id, payload) throws ValidationError
- emit() with empty string for required field throws ValidationError
- query() with no filters returns all events up to limit (default 100)
- query() with cursor pointing to non-existent event_id returns empty result
- verify() on empty chain returns { intact: true, total: 0, broken: [] }
- verify() detects cascading breaks (tampered event N causes N through end to fail)
- JSONL store: corrupt line during read is skipped, not fatal
- JSONL store: file doesn't exist yet on first write — create it
- HMAC key provided but event has no signature field — sign it
- Event has signature field but no HMAC key configured — throw SignatureError on verify
- Payload with nested objects must be sorted recursively in canonical JSON
- Payload with special characters (unicode, emoji) must serialize consistently

## Open Questions
- [ ] None — SPEC.md covers all design decisions

## Out of Scope
- External trust anchoring (Rekor, S3 object-lock)
- KMS/HSM integration or key rotation
- Compliance event schemas or evidence bundle export
- OTel/LangChain/CrewAI adapters
- CLI tooling
- Async batching, retention/TTL, pub-sub
- UI/dashboard

## Acceptance Criteria
- [ ] TrailEvent dataclass/interface has all 10 fields with correct types
- [ ] Error hierarchy: TrailproofError > ValidationError, StoreError, ChainError, SignatureError
- [ ] Error messages follow format: "Trailproof: {what} — {context}"
- [ ] Canonical JSON produces identical output in Python and TypeScript for the same input
- [ ] Hash chain produces identical hashes in both SDKs for the same event sequence
- [ ] Genesis hash is "0" x 64 in both SDKs
- [ ] emit() validates required fields and throws ValidationError on missing/empty
- [ ] emit() auto-generates event_id (UUID v4) and timestamp (ISO-8601 UTC)
- [ ] emit() computes hash and links to previous event's hash
- [ ] query() supports all filter fields with exact match
- [ ] query() supports from_time/to_time range filters
- [ ] query() supports cursor pagination with limit
- [ ] verify() returns VerifyResult { intact: true } for untampered chain
- [ ] verify() returns broken indices for tampered events
- [ ] verify() on empty chain returns { intact: true, total: 0, broken: [] }
- [ ] get_trace() returns events filtered by trace_id, ordered by timestamp
- [ ] flush() persists any buffered data (no-op for memory store)
- [ ] Memory store implements full store interface
- [ ] JSONL store: append-only, one JSON object per line, 0o600 permissions
- [ ] JSONL store: recovers last_hash and count from existing file on init
- [ ] JSONL store: handles corrupt lines gracefully (skip + warn)
- [ ] HMAC signer: signs events with "hmac-sha256:<hex>" format
- [ ] HMAC signer: verifies signatures with timing-safe comparison
- [ ] Trailproof constructor accepts store type, path, signing_key, default_tenant_id
- [ ] Both SDKs pass shared test vectors from fixtures/test-vectors.json
- [ ] Python API uses snake_case, TypeScript API uses camelCase
- [ ] Zero runtime dependencies in both SDKs

## Testing Guidelines
Create test files covering:
- emit: happy path, missing required fields, empty strings, optional fields, auto-generated fields
- chain: canonical JSON determinism, hash computation, genesis hash, chain linking
- query: no filters, single filter, multiple filters, time range, pagination with cursor, empty results
- verify: intact chain, single tampered event, cascading breaks, empty chain
- stores: memory store CRUD, JSONL store append/read/recovery, corrupt line handling, file permissions
- signer: sign event, verify valid signature, reject tampered signature, timing-safe comparison, missing key
- parity: shared test vectors produce identical results in both SDKs
